// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.1
// - protoc             v5.26.1
// source: api/builder/v1/tx.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationTxBuildTx = "/api.builder.v1.Tx/BuildTx"
const OperationTxGetBalance = "/api.builder.v1.Tx/GetBalance"
const OperationTxSendRawTx = "/api.builder.v1.Tx/SendRawTx"
const OperationTxSendTx = "/api.builder.v1.Tx/SendTx"

type TxHTTPServer interface {
	BuildTx(context.Context, *TxInfoRequest) (*BuildTxReply, error)
	GetBalance(context.Context, *BalanceRequest) (*BalanceReply, error)
	SendRawTx(context.Context, *SendRawTxRequest) (*SendRawTxReply, error)
	SendTx(context.Context, *TxInfoRequest) (*SendRawTxReply, error)
}

func RegisterTxHTTPServer(s *http.Server, srv TxHTTPServer) {
	r := s.Route("/")
	r.POST("/tx/build", _Tx_BuildTx0_HTTP_Handler(srv))
	r.POST("/tx/send_raw", _Tx_SendRawTx0_HTTP_Handler(srv))
	r.POST("/tx/send", _Tx_SendTx0_HTTP_Handler(srv))
	r.POST("/tx/balance", _Tx_GetBalance0_HTTP_Handler(srv))
}

func _Tx_BuildTx0_HTTP_Handler(srv TxHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in TxInfoRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationTxBuildTx)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BuildTx(ctx, req.(*TxInfoRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*BuildTxReply)
		return ctx.Result(200, reply)
	}
}

func _Tx_SendRawTx0_HTTP_Handler(srv TxHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SendRawTxRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationTxSendRawTx)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SendRawTx(ctx, req.(*SendRawTxRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SendRawTxReply)
		return ctx.Result(200, reply)
	}
}

func _Tx_SendTx0_HTTP_Handler(srv TxHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in TxInfoRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationTxSendTx)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SendTx(ctx, req.(*TxInfoRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SendRawTxReply)
		return ctx.Result(200, reply)
	}
}

func _Tx_GetBalance0_HTTP_Handler(srv TxHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in BalanceRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationTxGetBalance)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetBalance(ctx, req.(*BalanceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*BalanceReply)
		return ctx.Result(200, reply)
	}
}

type TxHTTPClient interface {
	BuildTx(ctx context.Context, req *TxInfoRequest, opts ...http.CallOption) (rsp *BuildTxReply, err error)
	GetBalance(ctx context.Context, req *BalanceRequest, opts ...http.CallOption) (rsp *BalanceReply, err error)
	SendRawTx(ctx context.Context, req *SendRawTxRequest, opts ...http.CallOption) (rsp *SendRawTxReply, err error)
	SendTx(ctx context.Context, req *TxInfoRequest, opts ...http.CallOption) (rsp *SendRawTxReply, err error)
}

type TxHTTPClientImpl struct {
	cc *http.Client
}

func NewTxHTTPClient(client *http.Client) TxHTTPClient {
	return &TxHTTPClientImpl{client}
}

func (c *TxHTTPClientImpl) BuildTx(ctx context.Context, in *TxInfoRequest, opts ...http.CallOption) (*BuildTxReply, error) {
	var out BuildTxReply
	pattern := "/tx/build"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationTxBuildTx))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *TxHTTPClientImpl) GetBalance(ctx context.Context, in *BalanceRequest, opts ...http.CallOption) (*BalanceReply, error) {
	var out BalanceReply
	pattern := "/tx/balance"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationTxGetBalance))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *TxHTTPClientImpl) SendRawTx(ctx context.Context, in *SendRawTxRequest, opts ...http.CallOption) (*SendRawTxReply, error) {
	var out SendRawTxReply
	pattern := "/tx/send_raw"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationTxSendRawTx))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *TxHTTPClientImpl) SendTx(ctx context.Context, in *TxInfoRequest, opts ...http.CallOption) (*SendRawTxReply, error) {
	var out SendRawTxReply
	pattern := "/tx/send"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationTxSendTx))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
